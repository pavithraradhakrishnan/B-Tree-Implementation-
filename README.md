# B-Tree-Implementation-
Implementation of  Insertion and Naive delete in B + Tree


I. INTRODUCTION:

A B+ tree is an N-ary tree having variable and large number of children per node. B+ tree consists of a root, internal nodes and leaves. The root may be either a leaf or a node with two or more children. The primary value of a B+ tree is in storing data for efficient retrieval in a block-oriented storage context in particular, filesystems. This is primarily because unlike binary search trees, B+ trees have very high fanout (number of pointers to child nodes in a node, typically on the order of 100 or more), which reduces the number of I/O operations required to find an element in the tree. B+ Tree combines features of ISAM and B Trees. It contains index pages and data pages. The data pages always appear as leaf nodes in the tree. The root node and intermediate nodes are always index pages. These features are similar to ISAM. Unlike ISAM, overflow pages are not used in B+ trees. The index pages in a B+ tree are constructed through the process of inserting and deleting records. Thus, B+ trees grow and contract like their B Tree counterparts. The contents and the number of index pages reflects this growth and shrinkage. B+ Trees and B Trees use a "fill factor" to control the growth and the shrinkage. 

II. IMPEMENTATION OF THE CODE
The Insert part was implemented by considering two cases. First the header page is checked to be INVALID_PAGE, if true then the tree is empty and a new page is created. The first new page created is called the LEAF page. If the header page is NOT an INVALID_PAGE calling the _INSERT function inserted the key and Record Id.  The ROOTPAGE and HEADERPAGE is pinned and unpinned accordingly. After creating a RootEntry it is evaluated to NULL to check if a leaf split propagated to the root and performed a root split. The entryPage contains the data of the new entry which was given up from the level down in the recurrence process. The old root split becomes the left child of the new root.
For implementing _INSERT we first check if the type of the page is INDEX or LEAF. For index recurse and try to split and for leaf insert key and record Id. Then we check if the child is split if so we move it to the index page. If there is no space in the INDEX page we again perform split to insert a key. For making an equal split we create a temporary entry and copy all the key values to it and if there is no space in leaf we split and copy it to the index level the first record of the right child. In equal split Compare the key using BT.keyCompare ,If the value is positive the key goes on the newLeafPage Else on the currentLeafPage. After transferring the records current page to new page we insert and delete records from current page. We unpin the page when the page is dirty. For implementing _NaiveDelete we created a leaf page and an iterator ,using the function Findrunstart we determined the first page and recordId of the keys. If the record id is found delete the keys and Unpin the page as it is dirty.


